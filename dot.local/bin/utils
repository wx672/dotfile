#!/bin/bash

MUPDF="$(command -v mupdf) -C FDF6E3"
QB="/usr/bin/qutebrowser"
CS6="cs6.swfu.edu.cn"

### cd C-t
# zsk()
# {
# 	z $(sk --exact --select-1 --exit-0 --ansi --color=always \
# 		   < <(fd --max-depth 3 --type directory --type symlink \
# 				  --base-directory ${1:-.}))
# }

# https://github.com/arp242/uni/blob/master/dmenu-uni
# rofi -dmenu -i -font "FiraCode Nerd Font Mono 22" 
emoji()
{
	[ -z "$2" ] && { echo usage: "$0 <search|emoji> <search string>"; return 1; }

	CMD="$1"
	case $CMD in
		s*) chosen=$(uni -quiet \
						 -f "%(char l:3)%(wide_padding)%(cpoint l:8)%(name t)(%(block t))" \
						 search "$2" | sk --exact \
										  --select-1 \
										  --exit-0 | choose 0)
			;;
		e*) chosen=$(uni -quiet emoji ${2:-all} | sort --random-sort | sk -e10 | choose 0)
			;;
		*) echo usage: "$0 <search|emoji> <search string>"; return 0
		   ;;
	esac

	[ -z "$chosen" ] && return # Exit if none chosen.

	printf "$chosen\n" && { xsel -bi <<<$chosen; }
	# xdotool type "$chosen"
	# notify-send "'$chosen' copied to clipboard."
}

zpdf()
{
	local V="zathura --fork"
	local PDFHIST="$HOME/.pdf_history"
	
	while getopts :te OPT; do
		case $OPT in
			t) V="less" ;;
			e) vim "$PDFHIST"; return 0;;
			?) echo "Usage: zpdf [-te] [string]"; return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	OPTIND=1

	[ -e "$PDFHIST" ] || touch "$PDFHIST"

	PATTERN="$*"
	
	if [ -z "$PATTERN" ]; then
		sk < $PDFHIST \
		   --bind "enter:execute($V {})+abort" \
		   -e10 --ansi --color=always
	elif [[ "$PATTERN" == "/*" ]] && [[ -e "$PATTERN" ]]; then # pattern begins with a /
		$V "$PATTERN"
	else
		# look into cwd. select one if multiple matches
		local PDF=$(sk -e10 --ansi --color=always \
					   < <(fd -IFd1 -epdf.gz -epdf "${1##*/}"))
		
		if [ -z "$PDF" ]; then # if not in cwd, look into history
			local HIST=$(sk -e10 < <(rg -N "$PATTERN" $PDFHIST)) #select one
			
			# in case of empty
			[ -z "$HIST" ] && { 
				[[ -n "$PATTERN" ]] && \
					echo File "$PATTERN" not found.;
				return 1; }
			
			if [[ "$HIST" == *gz ]] && [[ "$V" != "less" ]]; then
				gzip -cd "$HIST" | "$V" -
			else
				"$V" "$HIST" 2>/dev/null
			fi
		else #found in cwd
			if [[ "$PDF" == *gz ]] && [[ "$V" != "less" ]]; then
				gzip -cd "$PDF" | "$V" -
			else
				"$V" "$PDF" 2>/dev/null
			fi
			# if not in PDFHIST, add it
			rg -q $(realpath "$PDF") "$PDFHIST" || realpath "$PDF" >> "$PDFHIST"
		fi
	fi
	return 0
}

skiv(){
	cd "${1:-.}" || exit 1;
	sk < <(fd -e png -e jpg -e gif -e pbm) \
	   -e10 --bind 'enter:execute(sxiv {} &)'
}

skvi(){
	(cd "${1:-.}" || exit 1;
     
	 x="$(sk -e10 --ansi --color=always \
	 		 --bind "ctrl-p:toggle-preview" \
			 --preview="bat {}" --preview-window=up:90%:hidden)"

	[[ -n "$x" ]] && vim "$x")
 }

#--preview='bat --color=always {1} | rg -B3 -A$LINES {cq}'
rgvi(){
	(cd "${1:-.}" || exit 1;
	 x="$(sk -e10 --ansi --color=always -d: \
	 		 --bind "ctrl-p:toggle-preview" \
             --preview='bat {1}' \
			 --preview-window="up:90%:hidden:+{2}-/3" \
			 -ic 'rg -i --color=always --line-number "{}"')"

	[[ -n "$x" ]] && vim "$(echo "$x"|cut -d: -f1)" "+$(echo "$x"|cut -d: -f2)")
}

quickmarks(){
	sk < ~/.config/qutebrowser/quickmarks \
	   --exact --bind "enter:execute($QB {-1} &)+abort" \
	   2>/dev/null

	return 0
}

play(){
	sk < <(fd -e mp4 -e mkv -e webm -e m4a -e mp3 -e rmvb -e avi -e flv) \
	   --exact --bind "enter:execute(mpv {})+abort"
	
	return 0
}

gmaps(){
	QUERY=""
	for WORD in "$@"; do
		QUERY="$QUERY%20$WORD"
	done
	($QB https://www.google.com/maps/search/$QUERY 2>/dev/null &)
}

google(){
    QUERY=""
    echo google: "$@"
    for WORD in "$@"; do
        QUERY="$QUERY%20$WORD"
    done
    ($QB https://www.google.com/search?q="$QUERY" 2>/dev/null &)
}

g(){ google "$@"; }

ddg(){
  QUERY=""
  echo duckduckgo: "$@"
  for WORD in "$@"; do
      QUERY="$QUERY%20$WORD"
  done
  ($QB https://duckduckgo.com/?q=$QUERY 2>/dev/null &)
}

ffshot(){ # screenshot
	ffmpeg -y -f x11grab -s 1920x1080 -r 1 -i "$DISPLAY" -vframes 1 /tmp/"$(date +%Y%m%d%H%M)".jpg &>/dev/null
}

# https://trac.ffmpeg.org/wiki/StreamingGuide
ffcast(){ # screencast streaming

    trap 'pkill screenkey' INT EXIT TERM ERR

    (screenkey --no-systray \
			   --opacity .3 \
			   --font-color red \
			   --font "Fira Code SemiBold" \
			   --font-size small &)
    
    ffmpeg -f x11grab -video_size 1366x768 -r 15 -i :0.0 \
           -c:v libx264 -tune zerolatency \
           -vf "format=yuv420p" -g 30 \
           -preset ultrafast \
           -f mpegts udp://224.0.0.1:2000
}

# https://stackoverflow.com/questions/16658873/how-to-minimize-the-delay-in-a-live-streaming-with-ffmpeg
ffclient(){ # multicast client side

    mpv udp://224.0.0.1:2000 \
        --no-resume-playback \
        --no-audio \
        --profile=low-latency \
        --no-cache --untimed --no-demuxer-thread --vd-lavc-threads=1
}

ffrec(){ # screen recording lossy

    trap 'pkill screenkey' INT EXIT TERM ERR

    (screenkey --no-systray --opacity .3 --font-color red --font "Fira Code SemiBold" &)
    
	ffmpeg -f x11grab -s 1920x1080 -r 25 -i :0.0 \
		   -c:v libx264 -preset superfast \
		   "$(date +%Y%m%d%H%M)".mp4
}

ffrec_lossless(){ # screen recording losslessly (very large file!)
	ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 \
		   -c:v libx264rgb -crf 0 -preset superfast \
		   "$(date +%Y%m%d%H%M)".mkv
}

mp4(){ # convert $1 to mp4
	#  -preset ultrafast
	ffmpeg -i "$1" -an -c:v libx265 "$1".mp4
}

ffrec_overlay(){ # recording screen and webcam
	# man ffmpeg-filters
	# use 'ffplay -f v4l2 -list_formats all /dev/video0' to check for available video_size
	# 1280x720 960x540 848x480 640x480 640x360

	ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 \
		   -f v4l2    -s 640x360   -r 25 -i /dev/video0 \
		   -f alsa -i pulse \
		   -filter_complex "overlay=W-w:H-h" \
		   -map 2:a \
		   -c:v libx265 -c:a aac -b:a 48k \
		   "$(date +%Y%m%d%H%M)".mp4
}

ffcam(){ # capture webcam
	# use 'ffplay -f v4l2 -list_formats all /dev/video0' to check for available video_size
	#  -preset superfast
	ffmpeg -f v4l2 -s 640x480 -r 30 -i /dev/video0 \
		   -f alsa -i pulse \
		   -c:v libx264 -qp 0 -c:a aac -b:a 48k \
		   "$(date +%Y%m%d%H%M)".mp4
}

# http://superuser.com/questions/611538/is-there-a-way-to-display-a-countdown-or-stopwatch-timer-in-a-terminal

function countdown(){
    [ "$1" ] || {
	echo "Usage: countdown <seconds>"
	return 1
    }
    date1=$(("$(date +%s)" + "$1"));
    while [ "$date1" -ne "$(date +%s)" ]; do
	    echo -ne "$(date -u --date @$((date1 - $(date +%s))) +%H:%M:%S)\r";
	    sleep 1
    done && espeak "time out"
}

function stopwatch(){
    date1="$(date +%s)";
    while true; do
	    echo -ne "$(date -u --date @$(($(date +%s) - date1)) +%H:%M:%S)\r";
	    sleep 1
    done
}

dict () { (/usr/bin/dict "$@" 2>&1 | bat;) }

e(){
	# if emacsclient -e "(if (> (length (frame-list)) 1) 't)" | /bin/grep -q t; then
	if wmctrl -xa emacs; then
		[ "$1" ] && emacsclient -n "$@" || emacsclient -ne "(recentf-open-files)"
	else
		[ "$1" ] && emacsclient -nc "$@" || emacsclient -nce "(recentf-open-files)"
	fi
}

emacs() { 
	e "$@"; 
}

# viewing markdown file in w3m. an alternative to mdless/mdcat
mdview(){
	#(cmark "$1" | w3m -T text/html)
	w3m -T text/html < <(cmark "$1")
}

speak(){
	(/usr/bin/espeak -s 140 -v mb-us1 "$*";)
}

# srtplay(){
# 	mplayer /dev/zero -demuxer rawvideo -rawvideo w=1024:h=128 -utf8 -sub "$*";
# }

ssh() {
	# if [ "$(ps -p $(ps -p $$ -o ppid=) -o comm=)" = "tmux*" ]; then
	if [[ $TMUX ]]; then
        tmux rename-window "$(echo "$*")"
        command ssh -X "$@"
        tmux set-window-option automatic-rename "on" 1>/dev/null
    else
        command ssh -X "$@"
    fi
}

mosh() {
	# if [ "$(ps -p $(ps -p $$ -o ppid=) -o comm=)" = "tmux*" ]; then
	if [[ $TMUX ]]; then
        tmux rename-window "$(echo "$*")"
        command mosh "$@"
        tmux set-window-option automatic-rename "on" 1>/dev/null
    else
        command mosh "$@"
    fi
}

propstring () {
  echo -n 'Property '
  xprop WM_CLASS | sed 's/.*"\(.*\)", "\(.*\)".*/= "\1,\2" {/g'
  echo '}'
}

booksearch () {
	LIBPATH=$HOME/Calibre
	[[ "$1" ]] || { echo Usage: 'booksearch <keywords>'; return 1; }
	calibredb list -s "$@" --with-library="$LIBPATH"/Calibre1
	calibredb list -s "$@" --with-library="$LIBPATH"/Calibre2
	calibredb list -s "$@" --with-library="$LIBPATH"/Calibre3
}

searchbook () {
    (booksearch "$1")
}

showcolor () {
	(for i in {0..255}; do printf "\x1b[38;5;%smcolour%s " "$i" "$i"; done)
}

colorshow () {
for fgbg in 38 48 ; do # Foreground / Background
    for color in {0..255} ; do # Colors
        # Display the color
        printf "\e[%s;5;%sm  %3s  \e[0m" "$fgbg" "$color" "$color"
        # Display 6 colors per lines
        if [ $(((color + 1) % 8)) == 4 ] ; then
            echo # New line
        fi
    done
    echo # New line
done
}

# WAL="/usr/local/bin/wal"

# themelight () {
# 	[ -x "$WAL" ] && ($WAL -q -n -l --theme base16-atelier-plateau)
# }

# themedark () {
# 	[ -x "$WAL" ] && ($WAL -q -n --theme tempus_autumn -b'#000000')
# }

pdf () {
    unoconv "$@"
}

ppt () {
	libreoffice --show "$@"
}

xls2x () { # xls -> xlsx
	libreoffice --convert-to xlsx "$1"
}

# To list all available formats: youtube-dl -F <URL>
ydl()
{
	#defaults
	#YDL="/usr/local/bin/youtube-dl"
    YDL="/usr/bin/yt-dlp"

	while getopts :f:p:sh OPT; do
		case $OPT in
			f) fmt="$OPTARG" ;;
			p) port="$OPTARG";;
			s) YDL="$YDL --write-subs --write-auto-subs" ;;
			h) echo "Usage: ydl [-h] [-f <fmt>] [-p <port>] [-s]"; return 0 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	OPTIND=1

    # TMPCLIP="/tmp/tmpclip"
    # if pgrep -f sway; then
	# 	[ -s "$TMPCLIP" ] && { wl-copy -n < "$TMPCLIP" && rm -f "$TMPCLIP"; }
	# 	urls=$(wl-paste -n)
    # else
	urls=$(xsel -bo)
    # fi

	while ! $YDL --proxy "socks5://127.0.0.1:${port:-7891}" -f "${fmt:-b}" "$urls"; do
		echo try again...
	done
	
    # pgrep -f sway && wl-copy -c ||
	xsel -bc
}

ypv()
{
    # play online media from youtube or bilibili
    # ypv - youtube best audio
    # ypv b|ba|bv|any_valid_format
    # ypv bilibili #for bilibili

    # in qutebrowser,
    # ';y' to overwrite the clipboard with selected url.
    # ';a' to append an url into clipbroad.

	YDL="/usr/bin/yt-dlp"
	#YDL="/usr/local/bin/youtube-dl"

    # default to youtube best audio format (ba)
    # bilibili for bilibili
    # any other string will be treated as one of the youtube-dl formats

	while getopts :f:p:h OPT; do
		case $OPT in
			f) fmt="$OPTARG" ;;
			p) port="$OPTARG";;
			h) echo "Usage: ypv [-h] [-f <fmt>] [-p <port>]"; return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	OPTIND=1
	
    # TMPCLIP="/tmp/tmpclip"
    
    # if pgrep -f sway; then
	# 	[ -s "$TMPCLIP" ] && { wl-copy -n < "$TMPCLIP" && rm -f "$TMPCLIP"; }
	# 	CLIP="wl-paste -n"
    # else
		CLIP="xsel -bo"
    # fi
    
    if [ "$fmt" != "bilibili" ]; then
        while read url; do
            echo playing "$url" '('"$fmt"')'
			while ! $YDL --proxy "socks5://127.0.0.1:${port:-7891}" \
					-f "${fmt:-ba}" -o - "$url" | \
					mpv --profile=noproxy - ; do
				# in case of Ctrl-c
				echo try again...
			done
        done <<< $($CLIP)
    else
        while read url; do
            echo playing "$url"
            mpv --profile=noproxy "$url"
        done <<< $($CLIP)
    fi
    # pgrep -f sway && wl-copy -c ||
			xsel -bc
}

cs6(){
	(st -e mosh "${1:-wx672}"@cs6.swfu.edu.cn &)
}

cs6v(){
    url="https://cs6.swfu.edu.cn/~wx672"
    base=${1:-tmp}
    movies=$(xsel -bo)

    cat <<EOF
Files to be downloaded:

$movies

EOF

    for m in $movies; do
        echo Downloading "$url"/"$base"/"$m" ...
        aria2c --no-conf --check-certificate=false -x16 "$url"/"$base"/"$m"
    done    
}

cs6r(){
	rsync -avLP --inplace --append cs6:public_html/"$1" .
}

# https://madebynathan.com/2011/10/04/a-nicer-way-to-use-xclip/
# A shortcut function that simplifies usage of xclip.
# - Accepts input from either stdin (pipe), or params.
# ------------------------------------------------
cb() {
  local _scs_col="\e[0;32m"; local _wrn_col='\e[1;31m'; local _trn_col='\e[0;33m'
  # Check that xclip is installed.
  if ! type xclip > /dev/null 2>&1; then
    echo -e "$_wrn_col""You must have the 'xclip' program installed.\e[0m"
  # Check user is not root (root doesn't have access to user xorg server)
  elif [[ "$USER" == "root" ]]; then
    echo -e "$_wrn_col""Must be regular user (not root) to copy a file to the clipboard.\e[0m"
  else
    # If no tty, data should be available on stdin
    if ! [[ "$( tty )" == /dev/* ]]; then
      input="$(< /dev/stdin)"
    # Else, fetch input from params
    else
      input="$*"
    fi
    if [ -z "$input" ]; then  # If no input, print usage message.
      echo "Copies a string to the clipboard."
      echo "Usage: cb <string>"
      echo "       echo <string> | cb"
    else
      # Copy input to clipboard
      echo -n "$input" | xclip -selection c
      # Truncate text for status
      if [ "${#input}" -gt 80 ]; then input="$(echo "$input" | cut -c1-80)$_trn_col...\e[0m"; fi
      # Print status.
      echo -e "$_scs_col""Copied to clipboard:\e[0m $input"
    fi
  fi
}

rcb () { # remote clipboard
    
    local PORT=${1:-33333}

    echo using port "$PORT" ...

    # at remote side (cs6) do, for example, 'echo hello | nc -4l 33333'
    { nc -4W1 cs6 "$PORT" || echo nc failed.; } | xsel -bi

    xsel -bo
}

# https://stackoverflow.com/questions/660613/how-do-you-hide-the-mouse-pointer-under-linux-x11
setmouse () {
	for i in $(DISPLAY=":0" xinput | grep Mouse | cut -d"=" -f2 | cut -b-2)
	do
		DISPLAY=":0" xinput --"$1" "$i"
	done
}

moff () {
   DISPLAY=":0" xdotool mousemove 3840 2160 # use xrandr to find out
   setmouse disable
}

mon () {
	DISPLAY=":0" xdotool mousemove 1366 768 # use xrandr to find out
	setmouse enable
}

settouchpad() {
	for i in $(DISPLAY=":0" xinput | grep Touchpad | cut -d"=" -f2 | cut -b-2)
	do
		DISPLAY=":0" xinput --"$1" "$i"
	done
}

toff () { # touchpad
	DISPLAY=":0" xdotool mousemove 3840 2160 # use xrandr to find out
	settouchpad disable
}

ton () {
	DISPLAY=":0" xdotool mousemove 1366 768 # use xrandr to find out
	settouchpad enable
}

xoff () {
	xset dpms force off; xset dpms force off; xset dpms force off; xset dpms force off
}

xon () {
	xset s off -dpms
}

loremipsum () {
	if [ "${1}" = "" ] || [ "${2}" = "" ]; then
		echo "Usage: loremipsum <paragraphs|sentences> <integer>"
	else
		curl -s http://metaphorpsum.com/"${1}"/"${2}" && printf "\n"
	fi
}
